在python3的版本中，对编程语言进行了大的改变和更新，所以向后兼容是强烈需要关注的地方。使用future module来引入新的功能到当前的语言体系中。在python2中，字符串是用字节来表示的，在python 3中，是使用unicode的字符来表示的，字节的字符串和文本的字符串的名称也是不同的。在2中，str类是字节的字符串，unicode类是文本的字符串。在3中，使用bytes和str单独表示各自的类型。在2中，print是一个语句来解释的，在3中，使用函数来解析的。作为语句来使用的场景是更强大的。作为函数使用的好处是可以指明结果输出的位置。最简洁的方式是使用默认的标准输出。引用是包使用最主要的方式。在2中，解析器首先进行相对的引入；如果没有找到的话，会在系统设定的path的各个目录中去找，先走相对引用，然后走绝对的引用。这种方式提供了足够的灵活性，但是隐含着巨大的风险。

在3中，明确的区分相对引用和绝对引用。不带leading period都是绝对的引用，带上leading period，就是相对的引用，从当前的目录中去引用模块，不在走system path中的各个路径。

3中，采取了更加安全和直接的表达方式来避免不必要的问题。2和3的差距还是比较大的，在异常处理的语句的写法也是不同的。


最早的解决字符问题的是用美国标准编码，美国标准编码是一个字典，说明字符和数字如何的表示，以及一些特殊符号应该如何表示。这种编码的缺点是每个字符对应一个字节，可是全球的字符太多了，因此，一种全球统一的编码因需而生。在python中，存在两种类型的字符：文件类型的字符和字节类型的字符。美

美国编码标准使用一个映射表。编程语言中，也提供两种转化，根据映射表中的一方去获得另外一方的值。

修饰器是在函数和类上添加代码的工具。从本质和核心上讲，装饰器是一个可以调用的事物，接收一个callable，然后返回一个callable。装饰器会采取一些行动之后，返回一个callable。函数是对象，也可以做函数的参数。装饰器对函数的修饰是多方面的。有一个需要注意的角度是装饰之前的函数和装饰之后的函数之间的关系是怎么样的？

对于修饰器的作用，其他的语言的等价物是怎么样的？

从javascript语言的解释和执行中逐渐的转换成c语言和系统接口的调用。

node的源代码阅读：

1. 加载可以帮助的头部文件；
2. 在一个命名空间中，声明类以及类的父类；
3. 初始化函数；
4. 对当前的上下文和环境对象进行必要的动作和修饰；

v8把javascript代码直接编译成机器码,知道一种神秘和信仰的力量，在这种力量的帮助之下，开拓自己的疆土。

加载其他的模块和对象，在阐述网络的内容的同时，把一些简单的在上层的文件中说明出来，对于复杂的部分，使用单独的文件另外加以说明。

在网络编程的模型，根据socket的编程接口，书写出javascript版本的socket构造类的实现，在socket实现类的基础上，创造server的概念，提供http的服务。socket是在依赖tcp的基础上，server将协议用来处理http的request，依次给出网络的编程模型。

在浏览器的环境中，this指向window的对象；先拿出来之前underscore等价的事物；从现有的对象中分别获得它们的prototype对象；当前环境中，函数类型的对象才存在prototype对象，从这些prototype对象中拿出函数，把这些函数复制给新的名称，以局部变量的形式存在。

corda平台的主要组件有状态对象，合约代码，法律文书，交易，共识和流程。状态对象是最小的数据单元，代表金融系统中最小的数据片。状态对象会引用合约代码和法律文书，法律文书是可选的，为合约提供法律的保障。合约代码是强制性的，合约代码能够改变状态对象的状态。状态对象中包含代表当前状态的数据结构。交易用来实现不同状态之间的过渡。通过交易来实现状态的过渡是区块链中相同的概念。所有的交易都有熟悉签名。使用块来安排交易会派生挖矿的概念，corda没有使用这个概念，相反corda中的公证服务可以提供交易的顺序。新的交易类型可以使用字节码来开发，保证开发的灵活性和强大性。

两种共识：状态有效性和状态唯一性的共识。
