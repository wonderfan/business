# 2018-10-08

先从目录上进行划分，然后再从目录中的文件一个一个的审查；在阅读每个文件的时候，先从它的内容结构和轮廓图入手，对文件的里面的内容有个概略上的把握和认识。api目录中的内容主要是在接口的输入和输出数据模型的描述和定义；数据模型多的原因是因为业务的处理的面比较广。

Fabric ca sever的启动采用的main方法的形式，借助server cmd结构体对象和配置对象的帮助来完成这个过程。在cmd的独自目录和独立的结构体对象中，与lib目录中定义的配置对象和server结构体产生了联系，相互之间暗通曲款；互相的拉拢，从而产生了互动的交集。里面大多数是函数的运算和文件的读写操作；

在对区块的处理过程中，涉及到对区块的验证的功能；这个功能的实现沿用固有的接口和实现结构体的思路；验证的实现结构体完成了从消息信封到配置更新信封的转变；在它的一个方法中做了很多琐碎和细化的工作；譬如验证是否有权限，处理通道组的映射；到最后生成一个完整全新的结构体子元素和母元素。子元素的结构体对象上有一个序列的字段；生成一个新的时候，这个序列自动增加。

# 2018-10-09

信封是协议缓冲中的消息类型；实现的目标是两个协议缓冲之间的转换和构造。这两个消息的类型是有大小之分的，一个消息类型包裹另外一个消息类型。当采用面向对象编程的时候，代码的出现的位置和顺序已经不是影响的因素。接口定义的行为和契约。管理者的接口约定了管理者的行为和实现的职责；管理者可以达到的目的是建立起成员服务实例以及根据特定的条件获得成员服务实例的列表；msp的接口明确了一个msp实例具有的方法结合，以及通过每个方法可以实现的目标；在本地的文件系统中寻找msp，根据提供的角色的名称；将角色的字符串以及go语言对象的表达形式转变成字节数组的形式。分别从目录中读取文件，依次将文件的内容变成对象的字段或者属性。这就变成了一个msp的配置的数据来源和形成方式。msp独立成章；实现了msp既定要求的任务；在一个单独的空间中存活相关的代码。

启动的过程也从配置说起；那个总的配置对象红其实涵盖了多个方面的配置信息；现在仅仅的关注msp这个维度的配置信息。

# 2018-10-10

安全的状态机符志算法，以多个验证节点开始；在提交之前，验证节点需要进行两轮的投票；共识的部分有三个组件：提案，投票和锁定。

检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自选锁。乐观并发控制适用于低数据争用，写冲突比较少的环境

具体来说，MVCC 克服了先前基于表和行的锁定机制为主要手段的事务模式所存在的读写相互阻塞弊端，它是一种无锁的读写互不阻塞的并发控制机制，采用了每个数据都有多个版本，数据版本冲突等到事务提交的时候检查一下事务开始后，有没有新提交改变数据版本，如果没有就提交，如果有就放弃提交。这种行为模式也被称为乐观锁，相对宽松的乐观锁，允许多个操作同时进行，在没有数据冲突以及数据冲突较少的情况下，很容易获得较好的并发性能和处理效率。

把每个消息写入到日志文件中，以便于重放这些消息。点对点的协议包括配置，连接，节点。

# 2018-10-11

从历史解密上来说：和完备性来说；包的名称；导入的外部包；定义的新的类型；类型的名称是，类型是一个函数类型，这个函数类型接收两个输入参数，它的输出值是布尔的类型；这个函数类型是如何使用呢？需要给出一个具体的函数体就算是类型的实现吧。参数是字符串的数组，表示传递几个字符串进来作为输入参数；获取当前和当地的成员服务的类型；如果成员类型不符合要求的话，直接给出严重的错误；

客户端的命令需要一个参数，这个参数有多种决定的方式；在发送证书签名请求的时候，可以对客户端的配置文件进行定制；

一手打造的标准通道的成色和班底；在主体对象上挂载一系列的过滤器；这些过滤器都代表着一方的势力和处理；最重要的职责是对接受的到的消息进行分类；然后对分类后的消息分别的建立起处理的方式和逻辑。

把一个函数使用类型来定义，最重要的效果是为一类函数起一个统一的名称；在一个结构体中，有一些函数类型的字段；说明这个结构体的实例可以直接干些事情；

在接口的基础上把接口的实现类创作出来；这是从抽象思维过渡到形象思维的过程；沟通的桥梁是一个多金的少年；身上有着多重优秀的品质；从源代码上来进行解读和剖析；在这个负责连接工作的代码文件中，三个角色的组织关系是这样的：连接工厂负责连接的创造；连接储存负责连接和锁的集合工作，并把连接工厂的角色作为自己的内置属性；作为自己实现这个工作需要聚合的部分；

# 2018-10-12

在计算机的理论体系中；registry代表的是一类的处理方式，那就是寄存器；当数据从外部涌入到服务端的时候，这些数据使用统一的寄存器的安排数据的存储；具体的存储方式由存储器自己的内部的多种机制的实现，譬如同样是数据库，也可以使用不同的数据库来存储；服务端两个地方可以接受请求，那就是排序服务以及节点服务两个位置；我们可以仔细的观摩和跟踪一下，如何接受request，如何处理以及如何可以改进的地方；

Define the config for client, server, secure and keep alive side;

Extract the parameters from the client configuration object and transfer them into client attributes and fields; The most import method of grpc client is to create new connection; The connection object is created from grpc package through dialing the address endpoint with options;

When the secure side is considered for grpc connection; the various aspects are involved such as the credentials and certificate authority;

The content of credentials includes the root certificate authority; server name and certificates;

The composition of GRPCServer is made up of address, network listener, server from grpc package, server certificate, key pem file, mutex lock, client root certificate authority and tls configuration.

# 2018-10-13

The content in the server file contains how to create GRPCServer and how to create server from GRPC package and assign it to the GRPCServer instance;

What kind of this writing style belong to? What kinds of wisdom we can learn from this code file?

The order server receives the message from the client by the broadcasting interface;

Firstly, the remote address is extracted from the request context; Secondly, the infinite for loop is started and continue to receive the message from the client side;

When the message arrives at the server side; the channel support is constructed to analyze the message envelope; The steps of parsing and analysis as below:

1. Get the channel header from the envelope message;
2. Get the chain from the chains container by channel id;
3. If the chain does not exist in the current chain container, assign the system channel to the variable;
4. Classify the message envelope and get its type;


# 2018-10-20

There is one question that I am curious about. How does the peer node get the latest block from the orderer node?

使用一种形态去表述另外一种形态；使用一种语言去阐述另外一种语言的东西；在不同的世界和体系下找到彼此的对等物。

The deliver server is comprised of three small structures.javascript语言的语法中透漏着自由散漫的气息；不暴露key的合理性在哪里？discovery的result中包含哪些内容？我们应该如何拓展这个接口一遍获取更多的知识和信息？

在client和peer sever之间搭建的是discover的rpc接口；peer 启动的时候在grpc server上绑定了discover的接口；

在两个伙伴的帮助之下；类似桃源三结义：大哥叫discovery service；二哥叫service config，小弟叫service support；在创建一个服务结构体对象的基础之上；

从上下文中提取出来来自远方的地址；唐三藏从大唐而来；我们对他带的信物进行检查；安排一个特使来准备回馈的礼物；把一个的礼物放在同一个箱子里面；处理每个查询的条件；把每个查询的结果放到宝盒里面去；当礼物准备妥当之后，进行外观的包装；赠送给对方。查询的方式可以是多次，也可以是把多个查询条件封装在一次；发送一次获得多个结果；在拿到query后，调用dispatch的方法；在dispatch方法中，根据类型拿出一个query的处理函数；在go语言中，创建一个map的对象有两种方式；在创建的时候，要考虑哪一种更适合场景和更简洁以及更方便；

通过一个查询条件拿到过滤后的一个节点的集合；第一步是制作一个映射类型的集合；第二步是拿到所有的节点；并提取出所有节点的身份组成的一个集合；


# 2018-10-21

在结构体对象中植入一个接口类型的元素，可以起到两个作用：一方面将接口中定义的方法集合升级到结构体中；另外接口类型作为结构体的内置属性，可以接受一个接口类型的实现作为其字段的部分来处理；当结构体对象调用接口的方法的时候；解释器将这个调用转换为内置接口类型实现的调用. 适配器的接口由一个结构体的类型来实现；这个实现适配器接口的结构体还有另外一个特点，那就是采用内嵌结构体的方式继承了发送者结构体的财富和衣钵。

如何快速的抓住主线？或者关注整个体系中的某一个方面？这一次我们把目光投向底层语言是如何合理有效的阐释上层语言的？换句话，在解析上层语言的时候，如何把上层语言的符号转换和解析成底层语言的符号体系的。

一个项目中有若干的目录结构，我们可以从目录的名称上阅读出这个目录代表的方面和意思；也可以从大致的目录结构中捕捉出整个项目的组织结构和方式。

# 2018-10-22

扩展Fabric功能遵从的原则和实现方式

Fabric项目遵从功能模块化和组件插件化的设计哲学，在架构层面允许各个功能模块的可扩展性和互操作性。按照这一科学，合理，精良的架构特点和设计宗旨，Fabric实现了一个商业级区块链的基础要件和基本功能。鉴于Fabric目前功能实现的不完善性和局限性以及商业场景潜在的复杂需求，在Fabric具体的商业实践中，对Fabric现有的功能进行增强和补充在所难免。在对Fabric某个方面进行功能扩展和优化的过程中，若干的原则是需要秉持和坚守的，这不仅是为了保证新增功能质量的需要，这也是在设计哲学的风格上与整个Fabric保持一致，维持Fabric设计和构架风格的统一性和延续性的要求。这些具体的原则包括非侵入式扩展原则，渐进式增强原则以及测试驱动原则。这些原则的具体含义和实现方式分别一一的叙述如下：

非侵入式扩展原则

非侵入原则是以Fabric原有代码为内核，自开发功能与之松耦合，新增功能代码不过度依赖Fabric的原有代码，也不过分的侵入到Fabric的原有代码。这个原则的带来的直接收益是提供新增功能在不同版本的复用性，可以方便的在Fabric不同的版本中进行迁移，实现低代价的兼容Fabric的周期性升级。go语言丰富的语言特性和Fabric内置的多种机制为实现非侵入式功能扩展提供了多种方式。在go语言中，是以package来进行源代码的组织和管理的，在一个package里面增加新的go文件，不会破坏原有代码的结构和功能，并且新的go文件对原有的package中的对象元素具有访问性和扩展权；并且go语言支持内嵌的方式对接口和结构体类型进行灵活扩展，在实现继承关系上，没有采用显式的，强约束协议模式，为go语言实现非侵入式编程提供了巨大的空间。go语言从1.8之后，开始支持动态库的加载，这也为go语言实现非侵入式编程提供了强有力的支撑。Fabric要求go语言是1.9版本以上，在其内部的实现中也使用了动态库加载的方式，来支持自定义系统链代码的开发和加载。除了动态库的加载实现插件式编程以外，Fabric中采用了适当的设计模式来帮助扩展的灵活性，譬如pre/post模式，桥接模式，基类和辅助类的模式，单态模式，工厂模式等等；而且在Fabric中，基于stream的message收发机制是整个Fabric体系中实现消息通讯和流程处理的主要方式；借助于这个消息机制，通过自定义的消息类型和数据格式，来实现自定义的功能扩展，也是非侵入式扩展的体现方式之一。

非侵入性原则的实现方式也体现在自开发功能和模块风险可控这一要求上，实现这一要求的做法可分为两种，一种是通过配置文件的方式实现运行时的控制；另外一种是使用布尔常量控制标识，在编译阶段利用ldflags的可选项注入自开发功能的开关控制，这样可以轻松的实现自开发功能和Fabric原有功能的隔离。

渐进式增强原则

渐进式增强原则是对自开发功能的开发和发布流程提出来的要求。为了解决功能迭代的速度和稳定之间的矛盾以及降低重构的成本，在设计和扩展新的功能的时候,按照核心接口不变，stable的接口与experimental的接口都继承核心接口，experimental的结构体实现逐渐过渡到stable的结构体实现的办法和路径，从而完成在主接口不变的情况中，逐渐增强具体的功能细节和功能的渐进性增强。在Fabric的源代码中，特别是链代码的shim，stub，以及tx simulator那里，大量的采用了stable/experimental相结合的方式进行代码的迭代和演进。在自有功能的开发和发布过程中，坚持和贯彻这一原则对于自动有功能带到预期的目标和效果是大有裨益的。

测试驱动原则

在Fabric中，存在三种类型的测试，构成其Fabric整个项目的测试框架与体系，来保证Fabric代码的测试覆盖率与质量，它们分别是单元测试，行为驱动测试和集成测试。单元测试是整个测试体系的基础；它不仅可以验证代码的微小修改；确保代码逻辑正确，工作符合预期，没有缺陷，而且能够更快的实施行为驱动测试和集成测试。通过单元测试，及早发现问题，简化集成，拥抱变化是Fabric扩展开发过程中一个必要环节和过程。go语言内置了单元测试框架，只需要编写以test的后缀的go文件，通过go test命令行很容易执行单元测试代码，并且在go语言的测试框架中包含了性能的benchmark测试结果。在功能性和性能两个方面，确保代码的质量。开发的功能经过单元测试之后，进行集成测试，保证新增的代码不破坏原有的代码功能。


# 2018-10-23

在node中使用map的数据类型结构；node中对象解包和分包的代码书写方式；把异步的执行逻辑放在一个promise之中，也是一种安全的机制；从构造函数里面接受一个数组的参数；数组参数的元素是event hub的对象；grpc的client端判断是否已经连接上；注册所要监听的事物的对象，以及监听对象的数据到达的时候的处理函数。在common中抽象一些概念；在node中如何管理异常和错误的处理；在query的类中依赖connection的对象；

远程的机器发送的discovery的请求的时候，可以捕捉到来自那里的地址；在结构体中内置接口与内置结构体的异同；在一个接口之中；内嵌多个接口，可以理解为变相的接口的多继承；把多个接口内置到一个接口中，以及把多个接口内置到一个结构体类型中实现了不同的效果；在进行gossip的时候，在yaml的配置项中存在一个bootstrap的gossip地址；也就是当前的peer可以发生gossip的对象，并且自己的goosip的endpoint的设置也可以成为其他peer的bootstrap peer设置中的值。

在构造函数中接收元数据和连接简历；需要澄清出几个问题：在ca server启动的时候，bootstrap的user和password是放在哪里的？再就是没有重载私钥和证书的时候；证书的产生机制是怎么样的？

准确的说，启动的时候注册的用户和密码是写入到配置文件之中的；服务的进程所在的机器上的域名也会写入到默认的配置文件之中。最重要的这一步是把变量替换文件中的占位符；然后写成一个默认的配置文件，在server启动的时候完成两项壮举，一个是初始化，一个是完成http方面的处理器的注册。

在server的初始化过程中，完成了配置的初始化和默认ca的初始化；你中有我，我中有你。ca的初始化的过程包含的内容就特别的丰富多彩；包含的内容有配置的初始化；区块链密码服务提供商的初始化，私钥的初始化，数据库的初始化，登记签名者的初始化，这个签名者的在这里的具体含义是什么呢？三个文件一一的设置上默认值；key，cert，chain file。如果文件存在的话，验证key和cert是否匹配；怎么才算匹配呢？

# 2018-10-24

把system channel的配置信息查询出来，这些信息属于channel；做成数组，一次的放进去；按照什么样的方式来处理？合理的设计是怎么样的？主要还是看消息中包含哪些字段；第二点是字段的类型分别是什么样的？依次的按照decode和encode的方式组装起来；node的grpc是一种怎么样的思路和设计？它的输入参数是一个prototype的文件或者一个json的文件，读取文件之后将变成一个javascript的message的对象；主要是从结构上的对应；数据上的转换和方法是怎么来实现的？

在那个channel的envelope中包含了两个组成部分一个是config，一个是last update的部分；说明返回值中既囊括了当前的配置的部分，也包括了上一次的更新的部分；也算一个有良心的结果的呈现；拿到这个配置的部分之后；是一个对象，这个对象有一个变成buffer的方法，就是把这个对象变成二进制的形式；

把一个编码后的字节数组变成一个纯的js的对象；区块中包含通道的配置或者交易；区块的对象的对象组成结构；采用标注的形式对类型以及其他的说明作出格式化和可解读的书写；encode函数主体的主要逻辑：判断第一个参数是否为布尔的类型；除非第一个参数是buffer的类型；要不然创建一个新的初始化的字节缓冲的类型；

# 2018-10-25

如何进行选举？peer之间如何进行必要的选举？接口：方法的集合：使用一种方式聚合各个分散的方法；这些分散的方法有着内在的自然的联系；方法名以及输入参数和输出参数的名称和类型；go语言中的type和python中的type的意味有啥不同？主要是快速的反应出，当你看到这个type的语句的时候，心里和脑海中快速的给出答案啊。type 后面接的是两个方面的内容：类型名称以及类型的实体；那就是这个类型代表的内容；我们有了类型可以做什么以及如何做？ 类型赋予我们的是何种的便利条件和创作基础？

当你使用一个新的名称去描述一个已经存在的具体类型的形式的时候，这只是为那个已经存在的具体类型的形式给出了另外一个别名和使用形式，这算是语言书写和表达的一个手法和技巧而已；

一个函数的能力范围和所做的事情：为所要干的事情做好准备；开始计划的执行步骤；到达目标的实现；参数检查，创造实例对象，在一个单独的线程中启动；返回这个实例对象；

在结构体中确定好字段的列表和构成以及各自的类型,在启动的方法里面，我们看到的是多个例行程序的独自运行，使用一种通俗的话来说，那就是可以在指定的地点随意的生产和滋生新的新的任务的执行；换一个视角来看，是把一个实例对象的方法以各自独立的并发线程的形式运行起来；这些独立的线程蕴含着内在的关系，那就是它们共享一个内存的地址空间；这也是go语言的内存模型所设计和规定的。

# 2018-10-26

让法币为基础或者支撑的通证；会形成一个强健的分布式价值交换的方法和方式；区块链的创新点事全球化的可以审计和加密保证安全的账本系统；以资产为依据的通证发行方和市场参与方可以利用区块链技术来交易大众的，波动小的货币和资产。为了维护可信度以及交易价格的稳定，设计一种方法来维持加密通证和相关联的现实资产之间的一对一的存储比例。

这篇文章中引入共识的新模型：联邦拜占庭共识；联邦拜占庭共识通过切割法定大多数的方式实现鲁棒性。

比特币在共识机制上的设计有两个优秀的特点，一是采用激励的方式来促使理性的参与者行为正确；二是采用工作量证明的方式来驱除作恶者的行为。

# 2018-10-27

在接口文件中定义了账本接口、查询结果迭代接口、查询结果接口和删除策略接口;在账本的工具类的包目录和文件中，提供了关于目录的创建，列举，以及文件的存在之列的函数定义。这也是账本写入目录写入文件的需要。目录和文件的读写以及检索是数据读写的基本要义，也是linux的设计哲学，一切皆是文件的体现。当账本以block的形式来实现和体现的时候，这里面所需要的接口有工厂，读、写以及读写的复合接口等等。当把block文件当成其他的普通的来存储的时候，采用了一个分离的设计模式；机制和策略的分离的办法。在采用文件系统来作为区块的存储文件的时候，采用了几个机制，首先一个机制是检查点的机制，记录一个检查点，以检查点的信息作为新的信息的操作的依据。在这个处理之上，是否可以引入新的机制来解决。

# 2018-10-28

问题：在证书授权系统中，存在两个重要的资源：用户身份和证书，那么它们之间是怎么关联起来的？

在证书授权服务起动的时候，会产生一个配置文件，在这个文件中存在一个registry的项，在注册的调用的过程中，需要一个登陆的用户，这个用户与新注册的用户之间是附属的关联；可以根据附属的属性来明确两个之间的关系；另外一点是如果注册的用户没有提供密码的话，后台可以为其自动生成一个随机的密码，当这下数据写入数据库之后，把user和password作为响应的构成部分返回给前台的调用者。

在go语言的标准类库中实现一个log的功能；在log包中存在一个New的方法可以制造出一个满足多个方法接口的日志实例；这个日志实例的生产方法需要若干的参数；其中一个参数便是日志输出到哪里。标准输出或者标准错误输出都是可以有的选择。

在go语言中，一个数据片段可以使用一个结构体的对象来描述；其他通用的方式是使用json的方式；在struct和json之间可以使用tag的方式来建立之间的映射；这种做法也取决于序列化的包的实现和做法。证书里面的信息也是可以拆分和分解以及重新组装和合成的。按照规范和协议的形式进行分析和构造。

标准内库中加密定义的接口和方法：首先定义哈希是什么类型；以及哈希类型的持有的哈希函数的返回值；使用常量定义了加密的各种算法；在加密算法的实现上，现在已经存在各种类型和实现。

不同的加密算法所产生的摘要的长度是不同；使用一个数组作为一个集合将有限的几种情况囊括起来。

# 2018-11-03

创建client和cmd的对象的基础上生成一个client的对象，在这个对象的基础之上，放置了一个viper的实例；信任证书发放机构的机构和组织可以信任证书的持有者；如果证书授权机构可以保证加密信息的安全；也就是自己用来签名的私钥的安全的话；拿到证书的处理方就有权认为证书没有被修改；

Peer的本地的成员服务提供者的启动过程是怎么样的？每个msp的实例上分配一个默认的签名者？默认的签名者的资格和条件有哪些？


诵读经典或者朗诵经典：在国学经典中，那是一字一语，是文字，段落和书籍，在计算机的经典之中，是目录，是文件，是符合，是跳动的字节。这么多的目录和这么多的文件；我们的思绪该如何整理？那个开始的线索是什么？ 那就需要从一个个的形式文件；从它的形体找到它的灵魂。在这个过程中，有趣的是我们是否会再造经典？当我写下include的指令的时候，预处理是从哪来去读取头部文件？这涉及到了语言的编译原理；在c语言中，可以创造各式各样的函数，并且可以使用结构体来充当各种数据的描述对象。

如果一个函数是普普通通的众生中的一员，函数之中可以调用函数，这种潜在的安排，赐予将足量的函数连接起来迸发出难以想象的能力。

msp id 和组织的名称的关系是什么？

在peer启动的过程的时候，需要传入local msp id 的值，另外环境变量中也指明了msp 配置的路径；在channel配置的id的名称以及在peer的环境变量；一个文件完成本地的配置的加载工作；采用前缀的办法将日志以及成员服务初始化好；随后走向启动的过程；启动函数的主要内容是初始化网络服务的配置；构建起一个grpc的服务器对象；构建一个orderer的后端服务对象；将grpc的服务器与orderer的后端服务对象绑定起来；从而服务grpc的请求。在这若干的步骤之中，把目光的焦点投放到如何生成一个排序服务的签名者的步骤中来？在这里也看的更加的直接和明白了；这段代码的书写者的当时的所思所想，我们一眼也算看穿了；那就是用一个新的对象来来处理这个签名的事情；这个新的类型和存在的形式，我们怎么给他一个好的名词和概念呢？叫做代理合适吗？看来是要创造一个新的词汇了；并且这个文件采用的手法也是足够的巧妙；因为他定义的类型是在包中足不出户的；但是这个新的类型的方法却是可以在外面逍遥的。这个响应时代的号召而创造出来的新的类型；他也是做了一部分的工作；而把干活的部分交给了本地的成员服务对象。我们是不是也可以称这个现象或者做法叫做中间人的做法；一方面要从本地的成员服务中拿到签名的实体，将自己序列化后变成creator的值；从而成为组成签名者头部信息的一份子。

# 2018-11-04

身份混合成员服务的配置产生器：在产生证书授权的文件的基础之上，会在user的目录中增加一个默认的签名者，对于工具来说；主要是产生一个目录，包括私钥，公钥，以及在此基础上产生的签名者。

Idemix 是一个加密的协议套件，提供强的验证以及隐私保护的功能，譬如使用匿名性，可以在不揭示交易身份的条件下完成交易，譬如无关联性，一个单独的身份可以发送多笔交易，但是这些交易不能显示是来自同一个身份。在身份混合的流程中存在三个角色：用户，颁发者和验证者。

身份混合证书和x509证书： 一些属性给打上签名，签名是不能伪造的，每个证书后面都有一个私密的钥匙文件与之对应。

内核需要的文件，字符串，系统文件系统，导出、初始化、编译器、画像。一个个函数的定义和执行，在头部文件中定义类型、公共函数，在业务代码中，编写业务所需要的各种函数。

头部文件的依赖列表有内存管理、套接字、文件、网络、中断、线程、网络设备、进程文件系统、序列文件、模块、初始化、缓存、安全、挂载、系统调用、审计、无线等头部文件。

自己的组织想要保存自己的私有数据改如何保存？管理的头疼的问题包括智能合约的版本，智能合约的策略、以及成员服务的管理；避免这个头疼的问题的做法是在现有的通道中增加一个能力，那就是创建私有数据集合，也就是允许定义的一部分组织，也就是整个组织的子集合来背书，提交和查询私有数据；锚点节点负责跨组织的数据通信和传输。数据的哈希值会写入到那个通道的每个peer的账本中。哈希值当作交易的证据存留在每个账本系统中，也作为后来的审计目的。

私有的数据是通过节点与节点之间的传播来进行抵达的，而不是通过区块的形式进行数据流转的；把数据保存在本地的临时存储中，根据集合的策略，把数据分发到授权的节点上去。通过策略的形式在过滤数据到达和保存的节点数，并且可以在策略中增加额外的属性来达到限制和控制的作用。提出一个问题：私有数据的集合策略为什么要设置在智能合约上呢？智能合约是唯一能够改变账本数据和状态数据库的途径。当大家都参与到一个通道上的时候，可以在这个通道上安装智能合约以及调用智能合约；有一个直接的问题是加入到这个通道的组织都可以调用这个智能合约吗？
