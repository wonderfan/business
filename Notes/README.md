# 2018-10-08

先从目录上进行划分，然后再从目录中的文件一个一个的审查；在阅读每个文件的时候，先从它的内容结构和轮廓图入手，对文件的里面的内容有个概略上的把握和认识。api目录中的内容主要是在接口的输入和输出数据模型的描述和定义；数据模型多的原因是因为业务的处理的面比较广。

Fabric ca sever的启动采用的main方法的形式，借助server cmd结构体对象和配置对象的帮助来完成这个过程。在cmd的独自目录和独立的结构体对象中，与lib目录中定义的配置对象和server结构体产生了联系，相互之间暗通曲款；互相的拉拢，从而产生了互动的交集。里面大多数是函数的运算和文件的读写操作；

在对区块的处理过程中，涉及到对区块的验证的功能；这个功能的实现沿用固有的接口和实现结构体的思路；验证的实现结构体完成了从消息信封到配置更新信封的转变；在它的一个方法中做了很多琐碎和细化的工作；譬如验证是否有权限，处理通道组的映射；到最后生成一个完整全新的结构体子元素和母元素。子元素的结构体对象上有一个序列的字段；生成一个新的时候，这个序列自动增加。

# 2018-10-09

信封是协议缓冲中的消息类型；实现的目标是两个协议缓冲之间的转换和构造。这两个消息的类型是有大小之分的，一个消息类型包裹另外一个消息类型。当采用面向对象编程的时候，代码的出现的位置和顺序已经不是影响的因素。接口定义的行为和契约。管理者的接口约定了管理者的行为和实现的职责；管理者可以达到的目的是建立起成员服务实例以及根据特定的条件获得成员服务实例的列表；msp的接口明确了一个msp实例具有的方法结合，以及通过每个方法可以实现的目标；在本地的文件系统中寻找msp，根据提供的角色的名称；将角色的字符串以及go语言对象的表达形式转变成字节数组的形式。分别从目录中读取文件，依次将文件的内容变成对象的字段或者属性。这就变成了一个msp的配置的数据来源和形成方式。msp独立成章；实现了msp既定要求的任务；在一个单独的空间中存活相关的代码。

启动的过程也从配置说起；那个总的配置对象红其实涵盖了多个方面的配置信息；现在仅仅的关注msp这个维度的配置信息。

# 2018-10-10

安全的状态机符志算法，以多个验证节点开始；在提交之前，验证节点需要进行两轮的投票；共识的部分有三个组件：提案，投票和锁定。

检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自选锁。乐观并发控制适用于低数据争用，写冲突比较少的环境

具体来说，MVCC 克服了先前基于表和行的锁定机制为主要手段的事务模式所存在的读写相互阻塞弊端，它是一种无锁的读写互不阻塞的并发控制机制，采用了每个数据都有多个版本，数据版本冲突等到事务提交的时候检查一下事务开始后，有没有新提交改变数据版本，如果没有就提交，如果有就放弃提交。这种行为模式也被称为乐观锁，相对宽松的乐观锁，允许多个操作同时进行，在没有数据冲突以及数据冲突较少的情况下，很容易获得较好的并发性能和处理效率。

把每个消息写入到日志文件中，以便于重放这些消息。点对点的协议包括配置，连接，节点。

# 2018-10-11

从历史解密上来说：和完备性来说；包的名称；导入的外部包；定义的新的类型；类型的名称是，类型是一个函数类型，这个函数类型接收两个输入参数，它的输出值是布尔的类型；这个函数类型是如何使用呢？需要给出一个具体的函数体就算是类型的实现吧。参数是字符串的数组，表示传递几个字符串进来作为输入参数；获取当前和当地的成员服务的类型；如果成员类型不符合要求的话，直接给出严重的错误；

客户端的命令需要一个参数，这个参数有多种决定的方式；在发送证书签名请求的时候，可以对客户端的配置文件进行定制；

一手打造的标准通道的成色和班底；在主体对象上挂载一系列的过滤器；这些过滤器都代表着一方的势力和处理；最重要的职责是对接受的到的消息进行分类；然后对分类后的消息分别的建立起处理的方式和逻辑。

把一个函数使用类型来定义，最重要的效果是为一类函数起一个统一的名称；在一个结构体中，有一些函数类型的字段；说明这个结构体的实例可以直接干些事情；

在接口的基础上把接口的实现类创作出来；这是从抽象思维过渡到形象思维的过程；沟通的桥梁是一个多金的少年；身上有着多重优秀的品质；从源代码上来进行解读和剖析；在这个负责连接工作的代码文件中，三个角色的组织关系是这样的：连接工厂负责连接的创造；连接储存负责连接和锁的集合工作，并把连接工厂的角色作为自己的内置属性；作为自己实现这个工作需要聚合的部分；

# 2018-10-12

在计算机的理论体系中；registry代表的是一类的处理方式，那就是寄存器；当数据从外部涌入到服务端的时候，这些数据使用统一的寄存器的安排数据的存储；具体的存储方式由存储器自己的内部的多种机制的实现，譬如同样是数据库，也可以使用不同的数据库来存储；服务端两个地方可以接受请求，那就是排序服务以及节点服务两个位置；我们可以仔细的观摩和跟踪一下，如何接受request，如何处理以及如何可以改进的地方；

Define the config for client, server, secure and keep alive side;

Extract the parameters from the client configuration object and transfer them into client attributes and fields; The most import method of grpc client is to create new connection; The connection object is created from grpc package through dialing the address endpoint with options;

When the secure side is considered for grpc connection; the various aspects are involved such as the credentials and certificate authority;

The content of credentials includes the root certificate authority; server name and certificates;

The composition of GRPCServer is made up of address, network listener, server from grpc package, server certificate, key pem file, mutex lock, client root certificate authority and tls configuration.

# 2018-10-13

The content in the server file contains how to create GRPCServer and how to create server from GRPC package and assign it to the GRPCServer instance;

What kind of this writing style belong to? What kinds of wisdom we can learn from this code file?

The order server receives the message from the client by the broadcasting interface;

Firstly, the remote address is extracted from the request context; Secondly, the infinite for loop is started and continue to receive the message from the client side;

When the message arrives at the server side; the channel support is constructed to analyze the message envelope; The steps of parsing and analysis as below:

1. Get the channel header from the envelope message;
2. Get the chain from the chains container by channel id;
3. If the chain does not exist in the current chain container, assign the system channel to the variable;
4. Classify the message envelope and get its type;


# 2018-10-20

There is one question that I am curious about. How does the peer node get the latest block from the orderer node?

使用一种形态去表述另外一种形态；使用一种语言去阐述另外一种语言的东西；在不同的世界和体系下找到彼此的对等物。

The deliver server is comprised of three small structures.javascript语言的语法中透漏着自由散漫的气息；不暴露key的合理性在哪里？discovery的result中包含哪些内容？我们应该如何拓展这个接口一遍获取更多的知识和信息？

在client和peer sever之间搭建的是discover的rpc接口；peer 启动的时候在grpc server上绑定了discover的接口；

在两个伙伴的帮助之下；类似桃源三结义：大哥叫discovery service；二哥叫service config，小弟叫service support；在创建一个服务结构体对象的基础之上；

从上下文中提取出来来自远方的地址；唐三藏从大唐而来；我们对他带的信物进行检查；安排一个特使来准备回馈的礼物；把一个的礼物放在同一个箱子里面；处理每个查询的条件；把每个查询的结果放到宝盒里面去；当礼物准备妥当之后，进行外观的包装；赠送给对方。查询的方式可以是多次，也可以是把多个查询条件封装在一次；发送一次获得多个结果；在拿到query后，调用dispatch的方法；在dispatch方法中，根据类型拿出一个query的处理函数；在go语言中，创建一个map的对象有两种方式；在创建的时候，要考虑哪一种更适合场景和更简洁以及更方便；

通过一个查询条件拿到过滤后的一个节点的集合；第一步是制作一个映射类型的集合；第二步是拿到所有的节点；并提取出所有节点的身份组成的一个集合；


# 2018-10-21

在结构体对象中植入一个接口类型的元素，可以起到两个作用：一方面将接口中定义的方法集合升级到结构体中；另外接口类型作为结构体的内置属性，可以接受一个接口类型的实现作为其字段的部分来处理；当结构体对象调用接口的方法的时候；解释器将这个调用转换为内置接口类型实现的调用. 适配器的接口由一个结构体的类型来实现；这个实现适配器接口的结构体还有另外一个特点，那就是采用内嵌结构体的方式继承了发送者结构体的财富和衣钵。

如何快速的抓住主线？或者关注整个体系中的某一个方面？这一次我们把目光投向底层语言是如何合理有效的阐释上层语言的？换句话，在解析上层语言的时候，如何把上层语言的符号转换和解析成底层语言的符号体系的。

一个项目中有若干的目录结构，我们可以从目录的名称上阅读出这个目录代表的方面和意思；也可以从大致的目录结构中捕捉出整个项目的组织结构和方式。

# 2018-10-22

扩展Fabric功能遵从的原则和实现方式

Fabric项目遵从功能模块化和组件插件化的设计哲学，在架构层面允许各个功能模块的可扩展性和互操作性。按照这一科学，合理，精良的架构特点和设计宗旨，Fabric实现了一个商业级区块链的基础要件和基本功能。鉴于Fabric目前功能实现的不完善性和局限性以及商业场景潜在的复杂需求，在Fabric具体的商业实践中，对Fabric现有的功能进行增强和补充在所难免。在对Fabric某个方面进行功能扩展和优化的过程中，若干的原则是需要秉持和坚守的，这不仅是为了保证新增功能质量的需要，这也是在设计哲学的风格上与整个Fabric保持一致，维持Fabric设计和构架风格的统一性和延续性的要求。这些具体的原则包括非侵入式扩展原则，渐进式增强原则以及测试驱动原则。这些原则的具体含义和实现方式分别一一的叙述如下：

非侵入式扩展原则

非侵入原则是以Fabric原有代码为内核，自开发功能与之松耦合，新增功能代码不过度依赖Fabric的原有代码，也不过分的侵入到Fabric的原有代码。这个原则的带来的直接收益是提供新增功能在不同版本的复用性，可以方便的在Fabric不同的版本中进行迁移，实现低代价的兼容Fabric的周期性升级。go语言丰富的语言特性和Fabric内置的多种机制为实现非侵入式功能扩展提供了多种方式。在go语言中，是以package来进行源代码的组织和管理的，在一个package里面增加新的go文件，不会破坏原有代码的结构和功能，并且新的go文件对原有的package中的对象元素具有访问性和扩展权；并且go语言支持内嵌的方式对接口和结构体类型进行灵活扩展，在实现继承关系上，没有采用显式的，强约束协议模式，为go语言实现非侵入式编程提供了巨大的空间。go语言从1.8之后，开始支持动态库的加载，这也为go语言实现非侵入式编程提供了强有力的支撑。Fabric要求go语言是1.9版本以上，在其内部的实现中也使用了动态库加载的方式，来支持自定义系统链代码的开发和加载。除了动态库的加载实现插件式编程以外，Fabric中采用了适当的设计模式来帮助扩展的灵活性，譬如pre/post模式，桥接模式，基类和辅助类的模式，单态模式，工厂模式等等；而且在Fabric中，基于stream的message收发机制是整个Fabric体系中实现消息通讯和流程处理的主要方式；借助于这个消息机制，通过自定义的消息类型和数据格式，来实现自定义的功能扩展，也是非侵入式扩展的体现方式之一。

非侵入性原则的实现方式也体现在自开发功能和模块风险可控这一要求上，实现这一要求的做法可分为两种，一种是通过配置文件的方式实现运行时的控制；另外一种是使用布尔常量控制标识，在编译阶段利用ldflags的可选项注入自开发功能的开关控制，这样可以轻松的实现自开发功能和Fabric原有功能的隔离。

渐进式增强原则

渐进式增强原则是对自开发功能的开发和发布流程提出来的要求。为了解决功能迭代的速度和稳定之间的矛盾以及降低重构的成本，在设计和扩展新的功能的时候,按照核心接口不变，stable的接口与experimental的接口都继承核心接口，experimental的结构体实现逐渐过渡到stable的结构体实现的办法和路径，从而完成在主接口不变的情况中，逐渐增强具体的功能细节和功能的渐进性增强。在Fabric的源代码中，特别是链代码的shim，stub，以及tx simulator那里，大量的采用了stable/experimental相结合的方式进行代码的迭代和演进。在自有功能的开发和发布过程中，坚持和贯彻这一原则对于自动有功能带到预期的目标和效果是大有裨益的。

测试驱动原则

在Fabric中，存在三种类型的测试，构成其Fabric整个项目的测试框架与体系，来保证Fabric代码的测试覆盖率与质量，它们分别是单元测试，行为驱动测试和集成测试。单元测试是整个测试体系的基础；它不仅可以验证代码的微小修改；确保代码逻辑正确，工作符合预期，没有缺陷，而且能够更快的实施行为驱动测试和集成测试。通过单元测试，及早发现问题，简化集成，拥抱变化是Fabric扩展开发过程中一个必要环节和过程。go语言内置了单元测试框架，只需要编写以test的后缀的go文件，通过go test命令行很容易执行单元测试代码，并且在go语言的测试框架中包含了性能的benchmark测试结果。在功能性和性能两个方面，确保代码的质量。开发的功能经过单元测试之后，进行集成测试，保证新增的代码不破坏原有的代码功能。


# 2018-10-23

在node中使用map的数据类型结构；node中对象解包和分包的代码书写方式；把异步的执行逻辑放在一个promise之中，也是一种安全的机制；从构造函数里面接受一个数组的参数；数组参数的元素是event hub的对象；grpc的client端判断是否已经连接上；注册所要监听的事物的对象，以及监听对象的数据到达的时候的处理函数。在common中抽象一些概念；在node中如何管理异常和错误的处理；在query的类中依赖connection的对象；

远程的机器发送的discovery的请求的时候，可以捕捉到来自那里的地址；在结构体中内置接口与内置结构体的异同；在一个接口之中；内嵌多个接口，可以理解为变相的接口的多继承；把多个接口内置到一个接口中，以及把多个接口内置到一个结构体类型中实现了不同的效果；在进行gossip的时候，在yaml的配置项中存在一个bootstrap的gossip地址；也就是当前的peer可以发生gossip的对象，并且自己的goosip的endpoint的设置也可以成为其他peer的bootstrap peer设置中的值。

在构造函数中接收元数据和连接简历；需要澄清出几个问题：在ca server启动的时候，bootstrap的user和password是放在哪里的？再就是没有重载私钥和证书的时候；证书的产生机制是怎么样的？

准确的说，启动的时候注册的用户和密码是写入到配置文件之中的；服务的进程所在的机器上的域名也会写入到默认的配置文件之中。最重要的这一步是把变量替换文件中的占位符；然后写成一个默认的配置文件，在server启动的时候完成两项壮举，一个是初始化，一个是完成http方面的处理器的注册。

在server的初始化过程中，完成了配置的初始化和默认ca的初始化；你中有我，我中有你。ca的初始化的过程包含的内容就特别的丰富多彩；包含的内容有配置的初始化；区块链密码服务提供商的初始化，私钥的初始化，数据库的初始化，登记签名者的初始化，这个签名者的在这里的具体含义是什么呢？三个文件一一的设置上默认值；key，cert，chain file。如果文件存在的话，验证key和cert是否匹配；怎么才算匹配呢？

# 2018-10-24

把system channel的配置信息查询出来，这些信息属于channel；做成数组，一次的放进去；按照什么样的方式来处理？合理的设计是怎么样的？主要还是看消息中包含哪些字段；第二点是字段的类型分别是什么样的？依次的按照decode和encode的方式组装起来；node的grpc是一种怎么样的思路和设计？它的输入参数是一个prototype的文件或者一个json的文件，读取文件之后将变成一个javascript的message的对象；主要是从结构上的对应；数据上的转换和方法是怎么来实现的？

在那个channel的envelope中包含了两个组成部分一个是config，一个是last update的部分；说明返回值中既囊括了当前的配置的部分，也包括了上一次的更新的部分；也算一个有良心的结果的呈现；拿到这个配置的部分之后；是一个对象，这个对象有一个变成buffer的方法，就是把这个对象变成二进制的形式；

把一个编码后的字节数组变成一个纯的js的对象；区块中包含通道的配置或者交易；区块的对象的对象组成结构；采用标注的形式对类型以及其他的说明作出格式化和可解读的书写；encode函数主体的主要逻辑：判断第一个参数是否为布尔的类型；除非第一个参数是buffer的类型；要不然创建一个新的初始化的字节缓冲的类型；

# 2018-10-25

如何进行选举？peer之间如何进行必要的选举？接口：方法的集合：使用一种方式聚合各个分散的方法；这些分散的方法有着内在的自然的联系；方法名以及输入参数和输出参数的名称和类型；go语言中的type和python中的type的意味有啥不同？主要是快速的反应出，当你看到这个type的语句的时候，心里和脑海中快速的给出答案啊。type 后面接的是两个方面的内容：类型名称以及类型的实体；那就是这个类型代表的内容；我们有了类型可以做什么以及如何做？ 类型赋予我们的是何种的便利条件和创作基础？

当你使用一个新的名称去描述一个已经存在的具体类型的形式的时候，这只是为那个已经存在的具体类型的形式给出了另外一个别名和使用形式，这算是语言书写和表达的一个手法和技巧而已；

一个函数的能力范围和所做的事情：为所要干的事情做好准备；开始计划的执行步骤；到达目标的实现；参数检查，创造实例对象，在一个单独的线程中启动；返回这个实例对象；

在结构体中确定好字段的列表和构成以及各自的类型,在启动的方法里面，我们看到的是多个例行程序的独自运行，使用一种通俗的话来说，那就是可以在指定的地点随意的生产和滋生新的新的任务的执行；换一个视角来看，是把一个实例对象的方法以各自独立的并发线程的形式运行起来；这些独立的线程蕴含着内在的关系，那就是它们共享一个内存的地址空间；这也是go语言的内存模型所设计和规定的。

# 2018-10-26

让法币为基础或者支撑的通证；会形成一个强健的分布式价值交换的方法和方式；区块链的创新点事全球化的可以审计和加密保证安全的账本系统；以资产为依据的通证发行方和市场参与方可以利用区块链技术来交易大众的，波动小的货币和资产。为了维护可信度以及交易价格的稳定，设计一种方法来维持加密通证和相关联的现实资产之间的一对一的存储比例。

这篇文章中引入共识的新模型：联邦拜占庭共识；联邦拜占庭共识通过切割法定大多数的方式实现鲁棒性。

比特币在共识机制上的设计有两个优秀的特点，一是采用激励的方式来促使理性的参与者行为正确；二是采用工作量证明的方式来驱除作恶者的行为。

# 2018-10-27

在接口文件中定义了账本接口、查询结果迭代接口、查询结果接口和删除策略接口;在账本的工具类的包目录和文件中，提供了关于目录的创建，列举，以及文件的存在之列的函数定义。这也是账本写入目录写入文件的需要。目录和文件的读写以及检索是数据读写的基本要义，也是linux的设计哲学，一切皆是文件的体现。当账本以block的形式来实现和体现的时候，这里面所需要的接口有工厂，读、写以及读写的复合接口等等。当把block文件当成其他的普通的来存储的时候，采用了一个分离的设计模式；机制和策略的分离的办法。在采用文件系统来作为区块的存储文件的时候，采用了几个机制，首先一个机制是检查点的机制，记录一个检查点，以检查点的信息作为新的信息的操作的依据。在这个处理之上，是否可以引入新的机制来解决。

# 2018-10-28

问题：在证书授权系统中，存在两个重要的资源：用户身份和证书，那么它们之间是怎么关联起来的？

在证书授权服务起动的时候，会产生一个配置文件，在这个文件中存在一个registry的项，在注册的调用的过程中，需要一个登陆的用户，这个用户与新注册的用户之间是附属的关联；可以根据附属的属性来明确两个之间的关系；另外一点是如果注册的用户没有提供密码的话，后台可以为其自动生成一个随机的密码，当这下数据写入数据库之后，把user和password作为响应的构成部分返回给前台的调用者。

在go语言的标准类库中实现一个log的功能；在log包中存在一个New的方法可以制造出一个满足多个方法接口的日志实例；这个日志实例的生产方法需要若干的参数；其中一个参数便是日志输出到哪里。标准输出或者标准错误输出都是可以有的选择。

在go语言中，一个数据片段可以使用一个结构体的对象来描述；其他通用的方式是使用json的方式；在struct和json之间可以使用tag的方式来建立之间的映射；这种做法也取决于序列化的包的实现和做法。证书里面的信息也是可以拆分和分解以及重新组装和合成的。按照规范和协议的形式进行分析和构造。

标准内库中加密定义的接口和方法：首先定义哈希是什么类型；以及哈希类型的持有的哈希函数的返回值；使用常量定义了加密的各种算法；在加密算法的实现上，现在已经存在各种类型和实现。

不同的加密算法所产生的摘要的长度是不同；使用一个数组作为一个集合将有限的几种情况囊括起来。

# 2018-11-03

创建client和cmd的对象的基础上生成一个client的对象，在这个对象的基础之上，放置了一个viper的实例；信任证书发放机构的机构和组织可以信任证书的持有者；如果证书授权机构可以保证加密信息的安全；也就是自己用来签名的私钥的安全的话；拿到证书的处理方就有权认为证书没有被修改；

Peer的本地的成员服务提供者的启动过程是怎么样的？每个msp的实例上分配一个默认的签名者？默认的签名者的资格和条件有哪些？


诵读经典或者朗诵经典：在国学经典中，那是一字一语，是文字，段落和书籍，在计算机的经典之中，是目录，是文件，是符合，是跳动的字节。这么多的目录和这么多的文件；我们的思绪该如何整理？那个开始的线索是什么？ 那就需要从一个个的形式文件；从它的形体找到它的灵魂。在这个过程中，有趣的是我们是否会再造经典？当我写下include的指令的时候，预处理是从哪来去读取头部文件？这涉及到了语言的编译原理；在c语言中，可以创造各式各样的函数，并且可以使用结构体来充当各种数据的描述对象。

如果一个函数是普普通通的众生中的一员，函数之中可以调用函数，这种潜在的安排，赐予将足量的函数连接起来迸发出难以想象的能力。

msp id 和组织的名称的关系是什么？

在peer启动的过程的时候，需要传入local msp id 的值，另外环境变量中也指明了msp 配置的路径；在channel配置的id的名称以及在peer的环境变量；一个文件完成本地的配置的加载工作；采用前缀的办法将日志以及成员服务初始化好；随后走向启动的过程；启动函数的主要内容是初始化网络服务的配置；构建起一个grpc的服务器对象；构建一个orderer的后端服务对象；将grpc的服务器与orderer的后端服务对象绑定起来；从而服务grpc的请求。在这若干的步骤之中，把目光的焦点投放到如何生成一个排序服务的签名者的步骤中来？在这里也看的更加的直接和明白了；这段代码的书写者的当时的所思所想，我们一眼也算看穿了；那就是用一个新的对象来来处理这个签名的事情；这个新的类型和存在的形式，我们怎么给他一个好的名词和概念呢？叫做代理合适吗？看来是要创造一个新的词汇了；并且这个文件采用的手法也是足够的巧妙；因为他定义的类型是在包中足不出户的；但是这个新的类型的方法却是可以在外面逍遥的。这个响应时代的号召而创造出来的新的类型；他也是做了一部分的工作；而把干活的部分交给了本地的成员服务对象。我们是不是也可以称这个现象或者做法叫做中间人的做法；一方面要从本地的成员服务中拿到签名的实体，将自己序列化后变成creator的值；从而成为组成签名者头部信息的一份子。

# 2018-11-04

身份混合成员服务的配置产生器：在产生证书授权的文件的基础之上，会在user的目录中增加一个默认的签名者，对于工具来说；主要是产生一个目录，包括私钥，公钥，以及在此基础上产生的签名者。

Idemix 是一个加密的协议套件，提供强的验证以及隐私保护的功能，譬如使用匿名性，可以在不揭示交易身份的条件下完成交易，譬如无关联性，一个单独的身份可以发送多笔交易，但是这些交易不能显示是来自同一个身份。在身份混合的流程中存在三个角色：用户，颁发者和验证者。

身份混合证书和x509证书： 一些属性给打上签名，签名是不能伪造的，每个证书后面都有一个私密的钥匙文件与之对应。

内核需要的文件，字符串，系统文件系统，导出、初始化、编译器、画像。一个个函数的定义和执行，在头部文件中定义类型、公共函数，在业务代码中，编写业务所需要的各种函数。

头部文件的依赖列表有内存管理、套接字、文件、网络、中断、线程、网络设备、进程文件系统、序列文件、模块、初始化、缓存、安全、挂载、系统调用、审计、无线等头部文件。

自己的组织想要保存自己的私有数据改如何保存？管理的头疼的问题包括智能合约的版本，智能合约的策略、以及成员服务的管理；避免这个头疼的问题的做法是在现有的通道中增加一个能力，那就是创建私有数据集合，也就是允许定义的一部分组织，也就是整个组织的子集合来背书，提交和查询私有数据；锚点节点负责跨组织的数据通信和传输。数据的哈希值会写入到那个通道的每个peer的账本中。哈希值当作交易的证据存留在每个账本系统中，也作为后来的审计目的。

私有的数据是通过节点与节点之间的传播来进行抵达的，而不是通过区块的形式进行数据流转的；把数据保存在本地的临时存储中，根据集合的策略，把数据分发到授权的节点上去。通过策略的形式在过滤数据到达和保存的节点数，并且可以在策略中增加额外的属性来达到限制和控制的作用。提出一个问题：私有数据的集合策略为什么要设置在智能合约上呢？智能合约是唯一能够改变账本数据和状态数据库的途径。当大家都参与到一个通道上的时候，可以在这个通道上安装智能合约以及调用智能合约；有一个直接的问题是加入到这个通道的组织都可以调用这个智能合约吗？在节点上，智能合约的数据也是保存在本地的文件系统的。对于智能合约的数据的操作，包括查询可以根据查询文件系统上文件的读写方式，一个关键点是文件的格式和解析方式不是那么的直接，这个其实可以从现有的代码中剥离出来当作工具来使用。安装了智能合约的节点可以说是背书节点，那么提交节点是如何验证的呢？背书节点是需要执行交易的，交易的执行由智能合约的函数来执行.peer节点的进程和容器的进程都是依赖于本地的文件系统中的数据，所以在智能合约中的数据，或者系统智能合约的代码执行中，也能拿到账本的数据，使用另外一句话来说，账本数据和通道的配置数据是共享数据。


# 2018-11-08

使用锁的机制，根据通道的名称拿到通道的对象，或者叫做区块链的对象；从channel support 对象上拿到application configuration；判读application configuration 是否有组织的数据；如果有组织的数据，对组织进行遍历，从组织中拿到mspid，统一的放入到一个数组之中。使用借助于ssh的scp，因为后续还要对文件进行解压，这也是远程对目标机器的操作；在证书的生成过程中，使用了模版的技术；在配置定义模版，把值传递进去，渲染出值来。创建结构，把签名的签名证书保存到不同的目录；通过字符串的联合创建新的目录出来；对于排序服务分别是每个组织自己单独一个目录，每个目录下面分别是5个目录；在创建两个证书授权实例之后，调用产生验证成员服务的目录；

在软件工程中，行为设计模式是那些识别通用的沟通模式的设计模式。通过使用这些设计模式，可以提供对象之间的沟通和协作的灵活性。


# 2018-11-11

函数内变量生成，制作一个tls的配置对象，在这个配置对象里面有一个数组和来放置各个证书，获取peer节点的服务端的配置；这个函数的主体内容是构造一个服务配置对象作为返回值。断言的意思是说给出一个肯定的言论，如果是path的话，那么它的类型应该是字符串的类型；倘若不是的话，就抛出错误，告诉你传递的参数不是字符串的类型。当你传递路径的时候，对路径中的每一个字符做出分析。为了使得node的代码可以在不同的操作系统中运行和执行，针对不同的操作系统写出实现来；这就是为了实现跨平台可移植性所付出的代价。使用include的指令加载了三个头部文件，在node的命名空间之下，定义和展开元素的叙述；

# 2018-11-18

开始或者叫做启动的函数，接收两个输入参数，一个表示参数的个数，一个表示具体的参数。在开始的主体结构中执行平台的初始化，开始node自己的初始化，开始v8的初始化，然后执行uv默认的循环。进入到v8的头部文件中去浏览一番，在namepsace的隔离之下；开始书写各种类，其中重要的有平台类，孤立类、v8类、在源码文件的开始的地方加载各种头部文件；二级嵌套的命名空间.在原型对象上有一个方法，接受命令和可选项两个参数，可选项参数是一个map的类型；继承的写法是可以有多样的，类的继承到最后也是实现了不同类型的成员变量的复制罢了。在底层原生的基础上，构建一个新的东西出来；是在融合了基础的头部文件的内容，它这个新起的命名空间叫做原生抽象接口,在一个新的命名空间之下，创作出相同的类的名称，新的相同的类的名称是对之前的类的封装和扩展，把之前的类作为新的类中一个成员变量来调遣。在类的定义之中，使用范围的关键词来区分公用领域和私有领域。

# 2018-11-21

函数链条般的调用去执行主函数，开头使用hash字符的声明来使用python解释来解释当前的脚本；导入系统模块，平台模块以及操作系统模块，采用try和except的语句来判断是否支持多处理；把pylib目录加入到系统的path集合中，从而使得可以从新加入的path中来加载python的模块；使用import指令来检测是否可以导入加入导入路径的模块；定义各种函数，并通过执行函数来完成任务。c语言的开头和结尾的部分；开头的部分是加载头部文件，在加载完头部文件之后，便是各种常量的定义以及各种函数的定义；在书写c语言函数的时候，输入和输出函数的定义。在头部文件中，定义出新的概念所需要的数据结构以及各种数据模型的原型的定义。在不同的语言中，变量的类型有时候是在前面，有时候是在后面。

具体函数的剖析：通过一个函数来创建一个子进程；函数的输入参数是信号类型以及信号的数值；在函数主体刚刚开始的地方，进行局部变量的声明.

这个文档定义了两种509证书的扩展。第一个是把一组网络地址放到证书的主体中去；第二种是把一组自动的系统的身份标示绑定到证书的持有者那里。

在恶劣的条件下对分布式网络中的事件进行排序，通用的做法是拜占庭容错共识和原子广播，数字货币的成功。利用gossip的协议来简化和设计拜占庭的共识协议。

# 2018-11-24

> Essentially a container runtime is responsible for pulling down images from a registry, expanding them on disk and then executing them in a namespace.

# 2018-11-27

容器镜像的格式，构建镜像的方法，管理镜像的方式，管理容器实例的办法，分享容器镜像的方式，运行容器的方法，命名空间技术是在内核中将内核的资源进行分片，各自的进程只能看到自己的分配的资源。进程的身边标示，主机名称，用户的身份表示，文件名称，与网络访问有关的名称，以及进程之间的通信。

Linux系统启动的时候，每个类型有一个单独的命名空间，这些命名空间被所有的进程所使用。进程可以创造新的命名空间和加入不同的命名空间。

从规范，到参考实现，在参考实现中，摘要：以以太坊为基础的分布式账本协议，拥有交易和合约的隐私性以及新的共识机制。

延迟执行是把一个执行延迟，排序的输入输出事件的处理，五个头部文件加载进来；定义函数然后调用头部文件中的函数；在文件中定义的函数还被定义在头部文件中的宏所修饰；这也是元编程的启蒙吧。在这个文件，可以看到一个函数的一个特性，那就是函数类型是可以做输入参数，在函数主体中调用的。这么多的头部文件说明了这个系统的复杂性和宏大。从函数的名称上也可以看出端倪来，那就是函数的讲究。函数的原型定义以及函数的具体实现；函数名称使用的是带下划线的形式来书写，开始的部分是变量的声明的语句，这些语句包括了类型以及变量的名称；去找到执行语句，重要的执行，带有明显的计算的倾向的语句来阅读和观看。核心的思想仍旧是结构的变化，函数的执行。解析出参数来，获得参数类型的实例，从而使得函数在当前的范围内可以顺利被调用。

# 2018-12-02 

On top of the different container networking models are different approaches for software-defined networking (SDN). For the management plane, there are functionally two core approaches at this point: the Container Networking Interface (CNI) used by Kubernetes and the libnetwork interface used by Docker.

Kautz noted that with Docker recently announcing support for Kubernetes, it's likely that CNI support will be following as well.

Among the different technologies for container networking today are:

- Contiv - backed by Cisco and provides a VXLNA overlay model
- Flannel/Calico - backed by Tigera and provides an overlay network between each hosted and allocates a separate subnet per host
- Weave - backed by Weaveworks; uses standard port number for containers
- Contrail - backed by Juniper Networks and open sourced as the TungstenFabric project; provides policy support and gateway services
- OpenDaylight - open source effort that integrates with OpenStack Kuryr
- OVN - open source effort that creates logical switches and routers

''Upcoming Efforts''

While there are already multiple production grade solutions for container networking, the technology continues to evolve. Among the newer approaches is eBPF (extended Berkeley Packet Filter) for networking control, which is used by the Cilium open source project.

Additionally, there is an effort to use shared memory, rather than physical NICs to help enable networking.

# 2018-12-03

多机网络，服务的注册和发现是基础设施要解决的问题，而不是应用要解决的问题。在一个overlay的网络中，每一个容器都有自己独立的网络地址和名称，容器的网络接口和网络接口.知识系统的可扩展性和透明参数，构建和验证,语言和语法解析器。基于软件开发包的区块链，模块的规范说明书和链间标准的说明。默克尔存储持有状态，应用的地址，账户和交易的结构及其认证，发送的令牌，提案和投票的治理；权益证明的绑定和代理授权，验证节点的处罚机制，费用的转发，权益通证的产生和流转。链间通信协议，链间协议的主要内容包括两个链间严格顺序的消息传递和认证。创建一种机制，两个容错的复制状态机可以相互传递消息。这些消息提供了一个基础层来创立区块链沟通的架构。多个应用跑在各自的区块链上，有他们自己的状态和逻辑，链间的通信和沟通依靠顺序的消息队列来实现，允许复杂的链间的处理的可能性。数学密码学也就是现代密码学，阐释现代密码原理的数学基础；代数，数论和概率论，

# 2018-12-16

包括一个虚拟稀有云，多个交换机和几个自定义的路由，如果vpc没有指明，创建一个新的使用自己的参数，加载多个头文件，使用一个枚举的类型来表示rebase的几种已知的类型，根据值返回对应的枚举类型；相当于从命令行中读取传递的值的部分，判定rebase的类型；在头部文件中主要进行章节的说明，从抽象的层次上面来叙述，在代码文件中进行细节的实现和引用公共的函数来帮助处理业务逻辑。包含系统调用、信号递送、进程状态的变化、为什么有的语言有入口函数，有些语言没有入口函数;可以加载一个明确的字符串代表的文件；也可以加载一个函数，把函数的返回值作为加载的文件对象，这也是函数与函数之间的相互交互，以及把一个函数作为另外一个函数的参数。块设备名称的长度和卷名称的长度，从一个函数的过程中看到整个流程；从大的设计上来看，从细节上的看设计和实现，设置本地相关的设置；进行初始化，调用下一个事件函数来获取事件，调用分发事件的函数进行事件的派遣，使用条件判断和循环，直到没有事件为止，然后执行推出函数进行退出。网络地址是字符串的形式，解析成对象的形式，version 4和version 6；使用一个结构体来描述域名服务中的记录，结构的字段有目标的地址、端口、优先级、权重；使用结构体类型也可以刻画命名空间对象；主要是包含一个字符串类型的域名。根据文件读取到这个文件的描述符，在这个文件的描述符中，找到这个的地址类型，从而建立相应的连接。在文件描述对象上有left adddress的属性，使用type assertion，获取其类型，进行类型的switch循环。类型的主要作用是提供一个主心骨，在这个主心骨的基础上，可以绑定若干的行为。一个文件系统的最主要的工作是根据提供的文件名打开一个文件，返回一个文件的句柄。先读取请求中的数据，然后再写入到响应中去。这是暗藏着两种模式，一种是使用默认的http服务器实例，使用处理者以及处理函数两个接口，分别向默认的服务器实例注册相应url的处理函数或者处理者；随后监听给定的端口和启动服务；第三种方式是自己创建一个自定义的服务器实例，把必须的属性的值填充好之后，调用服务器实例的监听并启动的方法。

# 2018-12-31

基于网络的输入和输出；网络包会访问底层原始的网络功能；围绕网络，有固定的几个标准的接口：拨入、监听、接收、连接和监听者。每个交易经过系统处理后被划分成有效交易和无效交易；按照验证规则来划分成不同的延迟了交易的取消通知到前方的客户端；跨区块冲突、发生在模拟交易的阶段；块内的冲突，这个发生在排序服务的阶段。在模拟执行阶段，首先识别出上一个区块的唯一标示；

本身作为一个概念来描述检查点；这个检查点本身需要一些属性表示它具有检查点的资格。等待文件描述符上某些事件的发生；函数的输入参数是文件描述符、网络文件描述符、超时时长；输出参数是一个整数；等待文件中的一个进入准备好的状态，可以执行输入输出的读写操作。使用常量来代替；常量中包含多个属性的对象；

复杂的参数和对象纠缠在一起，如何保证自己不被迷失？自己的眼睛如何像火眼金睛一样不错过、不漏掉影响执行走向的细节？

在go语言里面什么时候使用指针？什么时候不使用指针？如何把握？自己使用的准则是什么呢？

接口定义以及接口中的方法的抽象；定义结构体类型；结构体类型中的属性的类型可以是接口的类型；定义的形式中可以包含抽象和具体；但是在具体类型的实例化中必须是具体的类型。

在一个结构体中内置一个接口和一个结构体的区别在哪里？还有一种我们可能容易忘记的类型，那就是函数类型，函数类型也可以作为参数来传递。创建一个匿名函数，并把这个函数赋值给一个变量。

# 2019-01-25

围绕海量复杂数据的存储、管理、整合、处理、 分析、展现、应用等主要环节，已经形成了新的大数 据产业体系。

共识算法：对交易的顺序达成共识。缓存的几种算法：最小频率使用算法；丢掉不被常用的缓存；

缓存算法也被称为缓存替换算法或者缓存替换策略；把最近使用或者常用的数据缓存到内存的位置来提高性能；当缓存满了的时候，算法要选择哪些缓存项被丢弃从而接收新的缓存项。

背书策略是一种静态的验证方法；管理身份才有权限修改背书策略；把交易组装和批处理成一个区块提高了广播的吞吐量；区块抵达到节点的方式有两种：一种是通过gossip的通道，一种是通过排序服务的广播；
